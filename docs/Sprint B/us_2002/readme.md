# US 2002 

## 1. Context
### 1.1. User Story Description

As Operator, I want to register an application of a candidate for a job opening and import all files received.

### 1.2. Customer Specifications and Clarifications


* Question 15: "É o Operador que regista uma candidatura ou é o sistema que o faz automaticamente? E como integra o “plugin” 
de verificação da candidatura neste processo?"

    * Answer: "Na US 2002 o Operator regista a candidatura. Para isso, é o Operator que inicia o processo mas o sistema
  deve importar os dados resultantes do Application File Bot de forma “automática” (Ver References da US 2002). 
  O plugin referido entre neste processo através da US 2003, em que o Operador gera um ficheiro template com os dados a 
  introduzir para validar uma candidatura. Na US 2004, o Operador, após preencher os dados específicos da candidatura 
  (com base no ficheiro template anterior) submete no sistema esse ficheiro que vai ser usado para o sistema avaliar/verificar 
  a candidatura. Se os critérios não forem atingidos a candidatura é recusada."


* Question 24: "Para identificar uma candidatura usa-se o id do candidato e o id do job opening?"

    * Answer: "Não é bem assim. As candidaturas vão entrar no sistema através dos ficheiros gerados pelo Application Email Bot.
  Esses ficheiros vêm identificados pelo Job Reference seguido de um “número” que identifica a candidatura a esse job reference. 
  Será tipicamente um número sequencial. No conteúdo desses ficheiros vai aparecer os dados do candidato. Repare-se que pode 
  até o candidato ainda não existir (não ter registo no sistema)."


* Question 65: "UI and UX. I'd like to know what is the expected flow of executing US2002 (application registration and files import,
  by the operator). Can you reproduce step by step which actions should the operator execute?

Example:
1. The system asks the operator for the candidate's email.
2. The operator enters the candidate's email.
3. The system asks for the job reference.
4. The operator enters the job reference.
5. The system creates the job application, if there is data for it in the shared folder."

   * Answer: "There are no specific requirements for the UI/UX but I think it will be more user friendly if the Operator could start
     the process by selecting the shared folder for the application to be imported."


* Q50 Bernardo – Relativamente aos ficheiros gerados pelo email file bot o que é que identifica o que cada ficheiro contém?

  * Answer: A50. De acordo com o que está no exemplo enviado, devem considerar que cada ficheiro tem sempre um prefixo único que 
identifica uma candidatura (um número inteiro antes do primeiro “-“). Todos os ficheiros com o mesmo prefixo pertencem à mesma candidatura. 
A seguir ao prefixo, se tiver “cv” é um curriculum, se tive “email” é o email enviado pelo candidato, se tiver “candidate-data” são os 4 dados 
de identificação da candidatura, tal como descritos em 2.2.3. Todos ao outros ficheiros com o mesmo prefixo devem ser considerados anexos.


* Question 74: "Relativamente ao registo dos candidatos, os dados devem ser inseridos manualmente ou importados do ficheiro com 
os dados do candidato?"

  * Answer: "Faz sentido que sejam importados do ficheiro, no âmbito da US2002. Eventualmente dar a possibilidade do utilizador 
  fazer alterações, caso seja necessário. A US2000a refere-se a uma funcionalidade do Operador, manualmente, registar candidatos. 
  (Nota: resposta actualizada em 2024/04/18, a negrito)."


* Question 78: "The operator can register a candidate: does he put the info manually or has to be read of the file generated by the bot? 
This user will appear then in the backoffice...enable as default I think. Then the admin, can also register manually a candidate as the 
operator did it? I don't understand at all the different between a registration of the candidate made by the admin or made by the operator."

  * Answer: "US2000a is for the Operator to manually register a candidate and his/her user in the system. US2002 is for import of the 
  applications from the data iin the files produced by the application file bot. If the candidate does not exist, it should be created. 
  I think there is no registration of a candidate by the admin."


* Question 83: "Na descrição da US o PO refere uma importação de ficheiros e depois na referência à mesma a importação dos dados do 
ficheiro. Poderia esclarecer a que se refere a importação? São importações distintas? Têm destinos diferentes?"

    * Answer: "Nessa US refiro-me à importação dos ficheiros gerados pelo Application File Bot. Quando me refiro aos dados, 
  serão os dados do ficheiro de texto “A text file with the data of the application and candidate”, secção 2.2.3, 
  um dos ficheiros gerados."


* Question 84: "Após a informação dos ficheiros que estiverem na shared folder forem utilizados pelo Operator para registar
uma candidatura, devem estes permanecer na pasta ou serem eliminados? Caso não sejam apagados como determinamos quais 
é que ainda não foram "utilizados"?"

  * Answer: "Admitindo que já foram importados para o sistema, não tenho requisitos adicionais quanto aos ficheiros. 
  A segunda pergunta é um problema que deve ser resolvido pela solução proposta. Eu não tenho nada a dizer sobre esse aspeto."


* Question 100: "O que é que tem de ser registado no sistema?"

  * Answer: "Tem de haver um registo que indique que o candidato em questão fez a candidatura e têm de ser registados/importados para 
  o sistema todos os ficheiros submetidos."


* Question: Q133 Sousa – US2002- Número da candidatura- na Q24 é referido um número que identifica uma candidatura a uma job reference. 
Esse número é diferente em todas as candidaturas, independentemente da job reference? Poderá servir como id da candidatura?
  * Answer: Para além da Q24 veja por favor os exemplos de ficheiros disponibilizados pelo applications email bot. Sim, podemos considerar que esse número é único, nunca se repetindo

* Question: Q136 Padilla – US200a, US1006 - I have understood that the registration of the candidate will always be done by the operator. I also have read this line in the documentation "The Operator of the 
Backoffice will import the files produced by the Applications File Bot and register the applications, creating candidates that dot not exist in the system" 
So I guess the mechanism that the Operator follows is display all the data of a candidate (US 1006), and if the system shows "this cadidate doesn't exit", the operator click in registering candidate (US 2000A) and then he/she registers the aplication, isn't it? 
Apart, could the Operator upload the CV of the candidate in the registering operation? or should it be done by the candidate in his/her console?
  * Answer: Please see Q74 and all the others that refer to US2002. US2002 regards the import of the files that result from the Application File Bot. This import results in the creation of the respective applications in the system and possible creation of candidate user if it does not exist already. 
  This is to be done automatically, without intervention of the operator. If, for some reason, the process encounters any problem (e.g., missing candidate date) it should interrupt the import a log/inform the operator. 
  There is no US for the candidate to upload his/her CV. This is only done by email. Also, there is no US (apart from US2002) to import data from candidates.

* Question: Q140 Pinto – US2002 – O que se entende por "and import all files received"? Devemos persistir todos os ficheiros para cada Candidate na base de dados ou apenas guardar o diretório de cada Application?  
* Answer: Aqui o termo importar deve ser visto mais como “consolidar” ou “registar” todos os ficheiros devidamente “incorporados” no sistema relativamente a uma candidatura. Normalmente isso poderia passar por importar esses ficheiros para a base de dados. 
No entanto, no contexto actual do projeto, pode passar apenas por registar alguma forma de acesso a esses ficheiros (por exemplo, guardando o caminho/path para os ficheiros que estão no “folder” partilhado ou outra forma similar)

## Explanation

* It involves a new feature to register Job Applications for the corresponding Job Opening for a candidate that is already in system if not the candidate should be created automatically.
* This task has not been assigned or completed in previous sprints; it's a new addition to enhance the functionality of the system.
  There are no bugs related to this task; it's a new feature implementation.

## 2. Requirements

**US 2002** As Operator, I want to register an application of a candidate for a job opening and import all files received.

## 3. Analysis

#### Use Cases:

* This user story will encompass use cases 2002.1 2002.2 according to the data present in the Specifications Document.
  ([Specifications_Document.md](..%2F..%2FGeneral%20Documentation%2FUse%20Case%20Diagram%2FSpecifications_Document.md)).

#### Functionality:

* The task aims to enable Operators to register a job Application for a job opening.

#### Understanding:

* As part of their responsibilities, Operators need the capability to register the job applications
  for a given Job Opening. This will involve typing the shared folder path and the candidate. 

#### Dependencies:

1. **US 2001 - As Product Owner, I want the system to, continuously, process the files produced by the Applications Email Bot, so that they can be imported into the system by initiative of the Operator.**

This story depends on the existence of files of the shared folder. Selecting the share folder for a Job Application to keep the path to where the files are. 


#### Acceptance Criteria:

- AC 2002.1: When selecting a requirement plugin, it must be previously registered in the system by the Language Engineer.
- AC 2002.2 : If the candidate its not registered it should be automatically created on the system

#### Input and Output Data

*Input Data:*

* Insert Data:
  * Path of the shared folder
  * Candidate email

*Output Data:*
* (In)Success of the operation



## 4. Design

### 4.1. Realization

### Sequence Diagram

![Sequence_Diagram_2002.svg](svg%2FSequence_Diagram_2002.svg)

### 4.2. Class Diagram

For UC 1005, the decision to omit a separate class diagram from the documentation is based on the principles of Domain-Driven
Design (DDD). Duplicating class information from the domain model would introduce redundancy. By directly utilizing the
domain model, clarity and efficiency are maintained in the documentation process while ensuring alignment with the project's
evolving domain understanding. [domain_model_v4.puml](..%2F..%2FGeneral%20Documentation%2FDomain%20Model%2Fdomain_model_v4.puml)



### 4.3. Tests

**Test 1:** 

```

@Test
    public void ensureJobApplicationEqualsPassesForTheSameiDApplication() {
        final JobApplication jobApplication = dummyJobApplication(iDApplication,candidate);
        final JobApplication anotherJobApplication = dummyJobApplication(iDApplication,anotherCandidate);

        final boolean expected = jobApplication.equals(anotherJobApplication);

        assertTrue(expected);
    }
}
````

**Test 2:**
```

@Test
    public void ensureJobApplicationEqualsFailsForDifferentiDApplication() {
        final JobApplication jobApplication = dummyJobApplication(iDApplication,candidate);
        final JobApplication anotherJobApplication = dummyJobApplication(anotheriDApplication,anotherCandidate);

        final boolean expected = jobApplication.equals(anotherJobApplication);

        assertFalse(expected);
    }
````

**Test 3:**
```

 @Test
    public void ensureJobApplicationEqualsIsEqualForTheSameInstance() {
        final JobApplication jobApplication = getNewJobApplication();

        final boolean expected = jobApplication.equals(jobApplication);

        assertTrue(expected);
    }
````

**Test 4:**
```

 @Test
    public void ensureJobApplicationsEqualsFailsForDifferentObjectTypes() {
        final JobApplication jobApplication = getNewJobApplication();

        final boolean expected = jobApplication.equals("a - string");

        assertFalse(expected);
    }
````
**Test 5:**

```

@Test
    public void ensureJobApplicationsIsTheSameAsItsInstance() {
        final JobApplication jobApplication = getNewJobApplication();

        final boolean expected = jobApplication.sameAs(jobApplication);

        assertTrue(expected);
    }
````
**Test 6:**
```

@Test
    public void ensureTwoJobApplicationsWithDifferentIdsAreNotTheSame() {
        final JobApplication jobApplication = dummyJobApplication(iDApplication,candidate);
        final JobApplication anotherJobApplication = dummyJobApplication(anotheriDApplication,anotherCandidate);

        final boolean expected = jobApplication.sameAs(anotherJobApplication);

        assertFalse(expected);
    }
````
**Test 7:**
```

  @Test
    void build() {
        String iD = "Application - 1";
        Candidate candidate = new Candidate("Jonh","Doe","jonhdoe@email.com","961234567");
        String filesPath = "docs/output_US2001/IBM-000123/1";
        State state = State.CONFIRMED;
        String rank = "Excellent";
        Date date = new Date();
        File file = new File("Files- Application 1",filesPath);

        JobApplicationBuilder builder = new JobApplicationBuilder();
         JobApplication jobApplication = builder.withiD(iD)
                .withCandidate(candidate)
                .withfile(file)
                .withState(state)
                 .withrank(rank)
                 .withDate(date)
                .build();

        assertEquals(iD, jobApplication.toDTO().getID());
        assertEquals(candidate.getEmail(), jobApplication.toDTO().getCandidate().getEmail());
        assertEquals(filesPath, jobApplication.toDTO().getFile().getFilesPath());
        assertEquals("Files- Application 1", jobApplication.toDTO().getFile().getName());
        assertEquals(State.CONFIRMED, jobApplication.toDTO().getState());
        assertEquals(rank, jobApplication.toDTO().getRank());
        assertEquals(date, jobApplication.toDTO().getDate());
    }
````

**Test 8:**

```

  @Test
    public void ensureFileEqualsPassesForTheSameNameApplication() {
        final File file = dummyFile(name);
        final File anotherFile = dummyFile(name);

        final boolean expected = file.equals(anotherFile);

        assertTrue(expected);
    }
````

**Test 9:**
```

  @Test
    public void ensureFileEqualsFailsForDifferentNameApplication() {
        final File file = dummyFile(name);
        final File anotherFile = dummyFile(anotherName);

        final boolean expected = file.equals(anotherFile);

        assertFalse(expected);
    }
````

**Test 10:**
```

@Test
    public void ensureFileEqualsIsEqualForTheSameInstance() {
        final File file = getNewFile();

        final boolean expected = file.equals(file);

        assertTrue(expected);
    }
````

**Test 11:**
```

@Test
    public void ensureFileEqualsFailsForDifferentObjectTypes() {
        final File file = getNewFile();

        final boolean expected = file.equals("a - string");

        assertFalse(expected);
    }
````
**Test 12:**

```

  @Test
    public void ensureFileIsTheSameAsItsInstance() {
        final File file = getNewFile();

        final boolean expected = file.sameAs(file);

        assertTrue(expected);
    }
````
**Test 13:**
```

@Test
    public void ensureTwoFileWithDifferentNamesAreNotTheSame() {
        final File file = dummyFile(name);
        final File anotherFile = dummyFile(anotherName);

        final boolean expected = file.sameAs(anotherFile);

        assertFalse(expected);
    }

```
### 4.4. Applied Patterns

#### Builder Pattern

We use the Builder pattern for creating a candidate because:

1. The Builder pattern allows us to separate the construction logic of a complex object from its representation. This
   means that the CandidateBuilder class is responsible for building a Candidate object.
2. With the Candidate Builder, we can define clear and concise methods for configuring Candidate attributes such as name,
   email, and phone number. This makes building the Candidate more readable and easier to understand.
3. The Candidate Builder can include validation logic to ensure that the data provided to create a Candidate is valid.
   For example, we can check if the provided email has a valid format or if the phone number contains only digits.
4. If the logic for creating a Candidate becomes more complex in the future, we can handle that complexity within the
   Candidate Builder while keeping the interface simple for its users.

#### Factory Pattern

The Factory pattern is employed in our system to facilitate the creation of repository instances, ensuring a flexible
and centralized approach to object creation. Here's why we utilize the Factory pattern:

1. The Factory pattern allows us to encapsulate the logic for creating complex objects, such as repositories, within
   dedicated factory classes.
2. By using a Factory, we abstract the process of object creation behind a common interface. This means that client code
   interacting with the factory doesn't need to know the specifics of how objects are created; it simply requests an object
   from the factory and receives the appropriate instance.
3. The Factory pattern offers flexibility in object creation by allowing different implementations of the factory to be
   used interchangeably. For example, we can have different factory implementations for in-memory storage and database-backed
   storage, and switch between them seamlessly based on our requirements.

#### DAO (Data Access Object) Pattern

The DAO (Data Access Object) pattern is used to encapsulate data access, providing an abstract interface to interact with
the database or any other data source. In our implementation, the DAO pattern can be identified in the CandidateRepository class.

1. The DAO pattern encapsulates data access operations such as saving, updating, retrieving, and deleting records. This
   allows database operations to be centralized in a single class, facilitating maintenance and reducing code duplication.
2. The DAO provides an abstract interface to interact with the data source, allowing the rest of the application to be
   independent of the specific database implementation.

#### Repository Pattern

We utilize the Repository pattern for managing candidate data because:

1. The pattern abstracts away the complexities of database interactions, allowing us to focus on business logic without
   directly dealing with database specifics.
2. The CandidateRepository interface provides a standardized way to perform Create, Read, Update and Delete operations on
   candidate entities. This uniform interface simplifies data access throughout the application.
3. Implementations like CandidateJpaRepository and InMemoryCandidateRepository handle specific data store interactions.


## 5. Implementation

### Main classes created

1. `JobApplication`: Represents a job application and stores information such as idApplication, file, the candidate, rank, state and date.

2. `JobApplicationBuilder`: Facilitates the creation of instances of the JobApplication class, validating the provided data
   during construction.

3. `File`: Represents a job application and stores information such as name and the files path.

4. `JobApplicationRepository`: Interface that defines methods for persistence operations related to job applications, such as
    finding jobapplications.

5. `FileRepository`: Interface that defines methods for persistence operations related to files.

6. `RegisterApplicationController`: Coordinates the business logic for adding a new job application, utilizing the JobApplicationBuilder
   and the JobApplicationRepository.

7. `RegisterApllicationUI`: User interface responsible for interaction to add a jobApplication, invoking the RegisterApplicationController
   for processing.


## 6. Integration/Demonstration

This functionality is integral to the operational workflow, allowing Customer Managers to efficiently list job applications to job openings with specific requirements.

To execute this feature:

1. Execute the `build-all` and `run-bootstrap` scripts to initialize the system.
2. Launch `run-backoffice` and log in as an Operator (e.g., Username: operator1, Password: operatorA1).
3. Access "2. Settings" and select "3. Register an application of a candidate".
4.  Provide the necessary information (share folder and candidate email).
5. It will appear an success mesage 
6. Back out twice by pressing "0" twice.



## 7. Observations

N/A