# US 2001 - As Product Owner, I want the system to, continuously, process the files produced by the Applications Email Bot, so that they can be imported into the system by initiative of the Operator
(#19)
## 1. Context
### 1.1. User Story Description

As Product Owner, I want the system to, continuously, process the files
produced by the Applications Email Bot, so that they can be imported into the system
by initiative of the Operator

### 1.2. Customer Specifications and Clarifications


* Question 64: US2001 - Bot restarts, duplicate files and final report. I would like to know what is the expected behaviour 
when the Application File Bot is restarted. Since the requirements state that files should be copied and not moved, the bot 
must know which files may have been already copied during previous runs of the program. Should the bot, on startup, check if
the existing files were already copied to the shared folder, should the files be moved instead of copied or any other solution? 
If you have no specific requirements for this case, only that the system is kept in a consistent state, I'd like to know what is 
the expected behaviour when the bot finds duplicate files. I'd also like to know if the file prefix generated by the Application 
Email Bot is guaranteed to be numeric and unique throughout the whole software solution lifecycle. One more question, regarding 
how the report system works. Should the bot create a report each time new files are found and moved to the shared folder, meaning 
that there are multiple reports simultaneously (for instance, identified via date and time in the file name), or should it be a
single file to which new data is appended?
    * Answer 64: A lot of questions for “a single question”. As stated in your question, the system should be kept in a 
consistent state. Regarding duplicate files, there should not be any duplicate files (why would duplicate files exist?). 
Regarding the report, there can be multiple report files, each one uniquely identified by some sort of timestamp.

* Question 67: US2001 - Número de Ficheiros. Em relação ao EmailFileBot, previamente respondeu que "Todos ao outros ficheiros 
com o mesmo prefixo devem ser considerados anexos", existe um número máximo/válido de ficheiros permitidos como anexos? Ou 
não controlamos o número de ficheiros submetidos por candidatura? Exemplo: CV, Email, Candidate-data e x opcionais?
    * Answer 67: Não está definido um número máximo, mas podem estabelecer um limite a configurar, por exemplo, num 
  ficheiro de configuração contendo um limite em tamanho (Mb) ou em número de anexos.

* Question 82: US2001 – Que tipo de informação irá conter o report feito pelo Application File Bot? Sendo que este report vai ser 
acerca de múltiplas candidaturas, com que periodicidade deverá este ser criado?
  * Answer 82: See Q64. I am not a technical person, but I should say that the report should include information that is enough 
  for diagnosing problems in the import. I think some form of configuration of detail to be reported should be interesting, like 
  what is usually available for log files, with a default rule for maximum detail.

* Question 93: [2001] Running Configurations – Gostaríamos de esclarecimentos relativamente ao método de seleção de 
parâmetros para a execução da aplicação. No documento de auxílio desta funcionalidade, é-nos informado que esta 
configuração pode ser feita através de um ficheiro de configuração ou através de input direto aquando a execução da 
aplicação através da linha de comandos. A nossa questão é: dá-se a escolher à priori a maneira como a configuração é 
feita (configuration file ou input), ou o grupo decide que método irá ser utilizado para a aplicação em desenvolvimento?
  * Answer 93: Penso que o documento que refere não é do documento principal de especificação do sistema, será um 
documento complementar com especificação especifica de uma unidade curricular. Sendo assim, penso que devem esclarecer 
a questão noutra fonte. Mas, sem querer condicionar a reposta “oficial” (que não é esta), penso que seja uma opção, 
e que cada solução pode considerar qual a que segue.

* Question 94: [2001] - Ficheiros novos e velhos – Relativamente à funcionalidade de us2001, os ficheiros gerados pelo 
Application Email Bot, são colocados num diretório, sendo depois processados pelo File Bot. Após um ficheiro ser 
processado pelo File Bot, este pode ser eliminado do diretório utilizado pelo Email Bot para guardar os ficheiros, uma 
vez que estes já se encontram organizados num shared folder?
  * Answer 94: Ver Q64. Como product owner .

* Question 130: Questão sobre o ficheiro do candidato - Gostaríamos de o inquirir sobre uma duvida do nosso grupo ainda retém 
quanto ao ficheiro mandado pelo candidato no seu processo para se candidatar a uma Job Opening, este ficheiro, que vai conter 
os seus dados, incluindo alguns já revelados por si como sendo o email, o numero de telefone e o nome, serão sempre os mesmos, 
para o mesmo candidato, ou e possível um candidato se candidatar com um ficheiro com um email diferente, um numero de telefone 
diferente e/ou um nome diferente?
  * Answer 130: Se o ficheiro chega com dados diferentes de todos os antes recebidos penso que não existe possibilidade de 
  sabermos que vêm da mesma pessoa, certo? Mas a resposta à vossa pergunta se calhar passa pela forma como se identifica 
  um candidato.


## 1.2. Explanation

* This task involves the development of a feature for continuous processing of files generated by the Applications Email 
Bot, aiming to facilitate their seamless import into the system. It is the first time this specific functionality is being 
developed, targeted at enhancing system automation and efficiency for the Product Owner and Operator roles.

## 2. Requirements

**US 2001** As Product Owner, I want the system to continuously process the files produced by the Applications Email Bot, 
so that they can be imported into the system by initiative of the Operator.

#### Use Cases:

* This user story will encompass use cases 2001 according to the data present in the specifications document 
([Specifications_Doocument.md](link_to_specifications_document)).

#### Functionality:

* The functionality entails the establishment of an automated process within the system to handle files generated by the 
Applications Email Bot seamlessly. It should continuously monitor for new files produced by the bot and initiate their 
processing for import into the system without manual intervention.

#### Understanding:

* The understanding of this requirement revolves around streamlining the import process of files produced by the 
Applications Email Bot into the system. By enabling continuous processing, the system reduces delays and manual efforts 
required from the Operator, enhancing overall efficiency. The automation should ensure timely integration of relevant 
data into the system, providing up-to-date information for decision-making processes.

#### Dependencies:

* No direct dependencies identified. However, the task might relate to the overall system architecture and user management
  functionalities defined in previous user stories.

#### Acceptance Criteria:

- AC 2001.1: The system should automatically detect and retrieve files produced by the Applications Email Bot at regular intervals.
- AC 2001.2: Upon detection, the system should initiate the processing of the files without manual intervention.
- AC 2001.3: Processed files should be imported into the system seamlessly, ensuring the accurate integration of data.
- AC 2001.4: The system should maintain a log of processed files and their status for tracking and audit purposes.

#### Input and Output Data

*Input Data:*

* Automatically generated files by the Applications Email Bot.

*Output Data:*

* Files processed (organized by job reference and application number) and imported into the system.

## 4. Design

### 4.1. Realization

As specified in **[readme_scomp.md](./readme_scomp.md)**


### 4.2. Tests (with MinUnit framework)


```
static char * test_extract_application_number() {
    printf("\nExtract application number test\n");
    char *path = "/home/josemendes/Área de Trabalho/US_2002/input/1-candidate-data.txt";
    int expected = 1;
    int obtained = extract_application_number(path);

    if (obtained == expected) {
        printf("Success! Expected: %d, Obtained: %d\n", expected, obtained);
        return NULL; // Teste passou
    } else {
        printf("Failure! Expected: %d, Obtained: %d\n", expected, obtained);
        return "Test failed"; // Teste falhou
    }
}
````

```
static char *test_extract_job_reference() {
    printf("\nExtract job reference test\n");
    char *path = "/home/josemendes/Área de Trabalho/us_2001/files/1-candidate-data.txt";
    char *expected = "IBM-000123";

    // Criar um arquivo e escrever o conteúdo esperado na primeira linha
    FILE *file = fopen(path, "w");
    if (file == NULL) {
        perror("Erro ao criar arquivo fictício");
        return "Test failed";
    }
    fprintf(file, "%s\n", expected); // Escrever o conteúdo esperado na primeira linha
    fclose(file);

    char *obtained = extract_job_reference(path);

    if (obtained == NULL) {
        printf("Failure! Obtained: NULL\n");
        return "Test failed"; // Teste falhou
    }

    if (strcmp(obtained, expected) == 0) {
        printf("Success! Expected: %s, Obtained: %s\n", expected, obtained);
        return NULL; // Teste passou
    } else {
        printf("Failure! Expected: %s, Obtained: %s\n", expected, obtained);
        return "Test failed"; // Teste falhou
    }
}
````

```
static char *test_mkdir_p() {
    printf("\nMkdir_p test\n");
    const char *test_path = "/tmp/test_directory/subdirectory";
    int result = mkdir_p(test_path);

    // Verificar se o diretório foi criado corretamente
    if (result == 0) {
        // Verificar se o diretório existe
        struct stat st;
        if (stat(test_path, &st) == 0 && S_ISDIR(st.st_mode)) {
            printf("Success! Directory %s created successfully.\n", test_path);
            // Remover o diretório criado após o teste
            rmdir(test_path);
            return NULL; // Teste passou
        } else {
            printf("Failure! Directory %s not created.\n", test_path);
            return "Test failed"; // Teste falhou
        }
    } else {
        printf("Failure! mkdir_p failed to create directory %s.\n", test_path);
        return "Test failed"; // Teste falhou
    }
}
````


## 5. Implementation

As specified in **[readme_scomp.md](./readme_scomp.md)**
